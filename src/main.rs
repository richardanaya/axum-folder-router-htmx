use axum::extract::FromRef;
use axum_extra::extract::cookie::Key;
use tower_http::services::ServeDir;
#[derive(Clone)]
pub struct AppState {
    key: Key,
}

impl FromRef<AppState> for Key {
    fn from_ref(state: &AppState) -> Self {
        state.key.clone()
    }
}

mod api_routes {
    // This is generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/routes.rs"));
}

#[tokio::main]
async fn main() {
    // Generate a secure key for cookie handling.
    // WARNING: In a real application, DO NOT generate the key on every startup.
    // Load it from configuration or environment variables to ensure consistency.
    // For demonstration purposes, we generate a new one each time.
    let key = Key::generate();

    // Create the application state.
    let app_state = AppState { key };

    // Build the router and provide the state.
    let app = api_routes::build_router()
        .fallback_service(ServeDir::new("public"))
        .with_state(app_state); // Provide the state here

    // Bind the listener and serve the application.

    // get PORT env or 3000
    let port = std::env::var("PORT").unwrap_or_else(|_| "3000".to_string());
    let port = port.parse::<u16>().unwrap_or(3000);

    let listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{}", port))
        .await
        .unwrap();
    println!("Listening on http://{}", listener.local_addr().unwrap());
    axum::serve(listener, app).await.unwrap();
}
